---
title:  "2018-01-03-CS343"
date:   2018-01-03 00:00:00 -0400
categories: CS343
layout: post
---
# CS 343

## Introduction


### 0.1 Why concurrency

* Processor speed has slowed (stopped)
* Use transistors from Moore's law for parallelism to increase speed
	* Every 18 months, double number of transistors
* But concurrent programming is still necessary to utilize parallel hardware
	* Very few devices run on single cores
* Some success in implicitly discovering concurrency in sequential programs
	* For a certain class of problems, can convert existing sequential programs into concurrent programs
* Alternately, programmer explicitly thinks about and specifies concurrency
	* Implicit and explicit approaches are complementary
	* Limitations of the implicit approach mandate the explicit approach


### 0.2 Why C++

* C++ is a dominant programming language
	* Based on C (large programmer- and code-base)
	* as efficient as C in most situations
	* Low-level features, eg. direct memory access, needed for
		* Systems programming
		* Memory management
		* Embedded / real-time
	* High-level features, eg. exception handling, objects, polymorphism, STL, etc.
	* Allows direct interaction with UNIX/Windows


### 0.3 Concurrency in C++

* C++ originally had no concurrency
	* C++11 only has simple concurrency
* Many different concurrency approahces for C++ have been introduced, with only varying degrees of adoption
* No de factor approach that dominates C++ concurrency programming
	* C has two but incompatible, pthreads and Win32
* C++'s simple concurrency limits its future in parallel computing
* Cannot be safely added to ANY language view library code


### 0.4 High-Level Concurrnecy

* In theory, and high-level concurrency approach can be used and adapted to C++. Some are better than others
	* C++ is class-based. Need to find a model that matches the models/architecture of your language
* We want a single consistent high-level powerful concurrency mechanism, but what should it look like?
* ...


### 0.5 mC++

Advanced control flow C++

* Integrated advanced control flow tightly packed into C++
	* Leverage class features
	* Threads are light-weight: M:N thread model versus 1:1
* Use mutex objects to contain mutual exclusion and synchronization


### 0.6 Outline

...


### 1 Advanced Control Flow (Review)

Basic and advanced control structures allow virtually any control flow

* Still, need more than ifs and whiles
	* eg. do-while, always at least once
		* whiles check at the top, and run through.
		* do-whiles run through, and checks at the bottom
		* What about the middle?

#### Multi-exit loop

```
for (;;) {
	// { priming }
	if (...) break;
}
```

* Can add loop index and take it out freely (as opposed to swap between whiles and fors)


### 1.1 Static multi-level exit

* Exit multiple control structures wher exit points are known at compile time
* Labelled exit (break/continue) provides this capability

```
mC++ / Java

L1: {
	// decs
	L2: switch (...) {
		L3: for (...) {
			...
			break L1; // exit block
			...
			break L2; // exit switch
			...
			break L3; // exit loop
		}
	}
}
```

### 1.2 Dynamic Memory Allocation

To avoid mark deductions, do not perform dynamic allocation unless necessary

* Dynamic allocation is bad for concurrent programming
* Sometimes, it's equally bad for sequential programming
* Stacks are more efficient for various reasons than heap allocation
	* Also, does not require explicit storage-management when working with stack

Fundamentally, when a variable's storage must outlive the block in which it's allocated, then it must be allocated on the heap

* Exceptions
	* Unknown amount of data (eg. reading from a stream)
		* Vectors heavily utilize the heap (in order to grow larger, needs to allocate heap space)
		* So, be careful of the structures you're using
	* ...
	* ...


### 2 Dynamic Multi-level Exit

* Routine activation (call/invocation) introduces complex control flow.
* Among routines, control flow is controlled by call/return mechanism.
	* Routine `h` calls `g` calls `f`
	* Cannot return from `f` to `h`, terminating `g`
* **Modularization**
	* Any contiguous code block can be factored into a (helper) routine and called from anywhere in the program (modulo scoping rules)
* Modularization fails when factoring exits, eg. multi-level exits
	* **Labels only have routine scope**
		* Be wary when moving labels and code (with variables) into a separate routine
		* This is a downstream consequence when switching a style of control flow

How would/could we fix this problem?

* Fundamentally, routines can have multiple outcomes
	* routine call returns normally, ie. statement after the call
	* exceptional returns, ie. control transfers to statements not after the call
		* eg. could not compute width or height, throw exception

[Notes 6]

* Fortran example
* Generalization of multi-exit loops and multi-level exits
* This Pattern addresses a few things
	* Algorithms can have multiple outcomes
	* Separating outcomes makes it easy to read and maintain a program
* Pattern does not handle case of multiple levels of nested modularization
	* ...

[Notes 7]

* Dynamic mutli-level exit extend call/return semantics to transfer in the reverse direction to normal routine calls, called a non-local transfer
* We can keep references of labels, and these are determined during run-time, hence dynamic exits

Non-local transfers

* Mechanism behind this is a label variable containing the tuple
	* Pointer to a block activation on the stack
	* Transfer point within the block
* **goto** L, in `f`, is a two-step operation
	* Direct control flow to the specified activation on the stack
	* Then go to the transfer point (label) within the routine
* Therefore, a label value is not statically/lexically determined
	* Recursion in `g` ==> unknown distance from `f` and `h` on stack
	* What if L is set during the recursion of `h`?
* Transfer between **goto** and label value causes termination of stack block
* ...


### 2.1 Traditional Approaches

* Return code
	* returns value indicating normal or exceptional execution
	* eg. printf() returns number of bytes transmitted, or a neg. val
* Status flag
	* Set shared (global) var indicating normal or exceptional execution
	* the val remains as long as it is not overwritten
	* eg. `errno` var in UNIX
		* Anytime a library routine is called, it will have a return code, put into `errno`
* Fix-up routines
	* a global and/or local routine called for an exceptional event to fix-up and return a corrective result so a computation can continue
	* eg. C++ has a global routine-pointer `new_handler` called when `new` fails
* Techniques are often combined
	* eg. we should probably check if printf() returns a neg. val, which indicates an error
	* We don't explicitly do this... ever
		* However, `errno` will be populated with `27`
		* `perror("printf:");
			* Looks up `errno==27` in its table and prints a message accordingly
	* Finally, can `abort()` if `printf()` fails
	* This means every library routine call should introduce a minimum of 3 additional lines
		* Who the fuck does this?
* Intermediate approach of return union, which mimics normal return type
* Return union combines result and return code, and checks code on result access
* ALL routines must return an appropriate union

[Notes 9]

* `malloc`, for instance, returns a storage, or a "no" message
	* ie. a union of the right and wrong outcome
	* Rust automatically dereferences and checks if `malloc` fails
		* Forces the check to be done, even if not explicitly performed
	* In Rust, it is literally a union: a struct that contains multiple values
		* eg. Result<void *, NoStorage>

Drawbacks

* Checking return code or status flag is optional
	* can be delayed or omitted, ie. passive vs. active
* Return code mixes exceptional and normal values
	* enlarges type or value range; normal/exceptional type/values should be independent
	* What if we can print negative characters? Then how can we find a value that could also be a return code?
	* If a routine uses all the positives and negatives, how can we steal one of those values to indicate an alternative result?
* Under no circumstance should a library routine abort the program
	* Should pass errors up so that someone else can make the decision as to what to do
	* The error should be passed up multiple levels (eg. A -> C, then back to A?)
* `errno` could have been changed many times since the error occurred
	*...
* Local fix-up routines increase the number of parameters
	* Increase cost of each call
	* Must be passed through multiple levels, enlarging parameter lists even when the fix-up routine is not used

...


### 2.2 Exception Handling (Model)

* Dynamic multi-level exit allows complex forms of transfers among routines
	* Exceptions aren't "errors"
	* They're a good way of moving away
	* Exceptions are alternate outcomes, though usually ancillary
	* Exceptional event is an event that is (usually) known to exist
		* Usually occurs with low frequency
		* eg. Division by zero, I/O failures, EOF
* Very difficult to simulate EHM using simpler control structures
* Exceptions are supposed to make certain programming tasks easier, like robust programs
* Robustness results because exceptions are active vs. passive; forcing programs to react immediately when an exceptional event occurs
* An EHM is not a panacea, and is only as good as the programmer using it


### 2.3 Execution Environment

* An OOP concurrent environment requires a more complex EHM than a non-object-oriented sequential environment
* Sometimes, need to walk through the stack frame and execute all destructores
	* Finally clauses are always executed
		* _Finally in mC++
* ...


### 2.4 Terminology

...


### 2.5 Static/Dynamic Call/Return

* Static: can deduce exactly what will happen
* Dynamic: when code is being executed, things and executions may change
	- Calls may return statically or dynamically


### 2.6 Static Propogation (Sequel)

* Case 1) static call, static return
* Sequel
	- Routine with no return value
		+ Sequel name is looked up lexically at the call site
		+ Though, control returns to the end of the block in which the sequel is declared
			* Doesn't go back to executing call, so no return values
	- Can change `breaks` into `sequels`
* Without sequels, it's impossible to modularize with static exits
	- Thus, propagation is along the lexical structure
* Adheres to the termination model, as the stack is unwound
* Sequel handles termination for a non-recoverable event (simple execution handling)

```
{
	sequel StackOverflow(...) {...} // handler
	class stack {
		void push(int i) {
			if (...) StackOverFlow(...); // 2nd outcome
		} // 1st outcome
		...
	}

	stack s;
	...
	s.push(3); // overflow?
}
```

* The second outcome is basically a simple exception. When it occurs, execution jumps outside of the sequel block
	- Problem, doesn't work for separate compilation
		+ Want to pull stack out into stack.cc?
			* What happens to StackOverflow? Where is the sequel?
			* The sequel has to be seen statically to know where it must jump to after execution
		+ This is the same issue with routines' scope issue
	- Only works for **monolithic** programs
	- Fails for modular (library) code as the static context of the module and user code are disjoint
* Advantage of the sequel is the handler is statically known (like static multi-level exit), and can be as efficient as a direct transfer


### 2.7 Dynamic Propagation


#### Case 3) dynamic call, static return

* Termination
* Also called dynamic multi-level exit	
* Advantage
	- Dynamic propagation works for separately-compiled programs
* Disadvantage
	- Handler is not statically known
	- Without dynamic handler selection, the same action and context for that action is executed for every exceptional change in control flow
	

##### 2.7.1 Termination

* Control transfers from the start of propagation to a handler --> dynamic raise (call)
* When handler returns, it performs a static return --> stack is unwound (like sequel)
* There are 3 basic termination forms for non-recoverable operation
	- non-local, terminate, retry
		* non-local transfer provides general machanism for block transfer on call stack, but has **goto** problem

**Terminate** provides limited mechanism for block transfer on the call stack (like labelled break)

* Catches are similar to sequel. They both have static returns, and jump to the end of the block (next line after block)

**Retry** is a combination of termination with special handler semantics

* ie. restart the guarded block handling the exception
* Pretend EOF is an exception of type Eof
	- Not supposed to get out of retry until contract is fulfilled
	- Can have alternative ideas than catch clauses
* With just a normal catch clause and a few extra lines, can simulate retries very easily
	- Don't need an extra construct, so C++, Java, etc. don't have it
* ...


##### Case 4) dynamic call, dynamic return

**Resumption**

* provides a limited mechanism to generate new blocks on the call stack
* control transfers from the start of propagation to a handler --> dynamic raise (call)
* when handler returns, it is a dynamic return --> stack is **not** unwound (like routines)
* Using `_CatchResume` clauses and `_Resume` raises, when the closing brace is reached in the `_CatchResume`, execution is returned to the `_Resume` call, not the next line after the handler
	- O(n) search, which we don't get from an O(1) return call
	- Normally, we'd have to pass a fixups around


### 2.9 Exceptional Control-Flow

Shits bonkers, yo


### 3.0 Coroutines

A **coroutine** is a routine that can also be suspended at some point and resumed from that point when control returns

* A calls B, B calls C, C goes back to B
	- That sounds like routine calls to me
		+ Yes! But, C doesn't terminate... (?)
* The state of a coroutine consists of
	- An **execution location**, starting at the beginning of the coroutine and remembered at each suspend
	- An **execution state**, holding the data created by the code the coroutine is executing
		+ Each coroutine has its own stack, containing its local vars and those of any routines it calls
	- An **execution status**, active, inactive, or terminated
		+ Changes as control resumes and suspends in a coroutine
* Not a normal routine because coroutine creates a new stack, and starts running there

* Coroutines handle the class of problems that need to retain state between calls
	- eg. plugins, device drivers, finite-state machines
* Coroutines exectue asyncly with other coroutines, hence no concurrency among coroutines
	- Coroutines are the precursor to concurrent tasks, and introduce the complex concept of suspending and resuming on separate stacks


When you create a routine, you don't declare whether its recursive or sequential.

* Semi-coroutines and full-coroutines are different types, non-declarative
	- Semi-coroutines act asymmetrically, like non-recursive routines, by implicitly reactivating the coroutine that previously activated it
	- Full-coroutines ...


### 3.1 Semi-Coroutine


##### 3.1.1 Fibonacci Sequence

* Direct method is simple enough
* Create a routine called `fibonacci()`
	- Problem, after every `fibonacci` call, we'd lose data regarding the already-computed values
	- We needed to introduce global `fn1` and `fn2` variables to retain state
	- Also, `fibonacci` has three different states
		+ if n==0, n==1, or n>1
			* Which state? They return different things
* Classes are fun, but still don't get the job done too well
	- We can create a `Fibonacci` class, and encapsulate our global variables
	- Also, can now have multiple instances, so create `fn1` and `fn2`
		+ next() generates the next Fibonacci number for the given instance
	- Still has flag variables

**Using coroutines**

```
_Coroutine Fibonacci {
	int fn;
	void main() {
		int fn1, fn2; // retained between resumes
		fn=0;
		fn1=fn;
		suspend()
		fn=1;
		fn2=fn1;
		fn1=fn;
		suspend()

		for (;;) {
			fn = fn1+fn2;
			fn2=fn1;
			fn1=fn;
			suspend()
		}
	}

	public:
	int next() {
		resume(); // only resume (which increments our fib number) when necessarily
		return fn;
	}
}

int main() {
	Fibonacci f1, f2;
	for (int i=0; i<=10; i+= 1) {
		cout << f1.next() << " " << f2.next() << endl;
	}
}
```

* No explicit execution state!
* `_Coroutine` type wraps coroutine and provides **all class properties**
* Distinguished member main (coroutine main) can be suspended and resumed
* No parameters or return value (supplied by public members and communication vars)
* `main` can be called (even recursively), but is normally private/protected
	- This is so that outsiders cannot fuck around with your coroutine
	- Outsiders can only interact with your coroutine in the ways you provide


**Coroutines do context switches**

* On resume, will context-switch over to the coroutine stack
* On suspend, will context-switch over to the main stack, or whoever called the coroutine
* For example above, the frame for next() goes on the main stack
	- Doesn't context switch until later. Sometimes, we don't even need to resume/suspend, so it's not a great idea to automatically context-switch
	- Even being on the main stack, it can still access variables from the coroutine(s) stack
	- Uses `this` variable to execute magic
* By using separate stacks, coroutines get the power that they do
* First `resume` starts main on new stack (cocall)
	- Subsequent resumes reactivate last `suspend`
	- `suspend` reactivates last resume
* Object becomes a coroutine on first resume
	- Coroutine becomes an object when main ends
* Routine frame at the top of the stack knows where to activate execution
	- `suspend`/`resume` are **protected** members to prevent external calls
		+ So other people can't diddle with your coroutine's execution
		+ Only `protected` when inheritance is needed
* Coroutine main does not have to return before a coroutine object is deleted
* When deleted, a coroutine's stack is always unwound and any destructors executed
	- Why?


##### 3.1.2 Format Output (Example)

* Unstructured input: `abcedfghijklmnopqrstuvwxyzabcedfghijklmnopqrstuvwxyz`
* Structed output

```
abcd efgh ijkl mnop qrst
uvwx yzab cdef ghij klmn
opqr stuv wxyz
```

* Blocks of 4 letters, separated by 2 spaces, grouped into lines of 5 blocks
* Traditionally, we'd use loops directly
	- [Notes 30]
	- If we try to modularize this code, we need to maintain variables for number of blocks and size of blocks
		+ Need to remember how many characters are in current block
* ...

* Coroutine trick
	- `resume` in the constructor
	- Normally, first time a public member is called, it will `resume`, which is the cocall and makes the stack
	- However, sometimes, we don't want the user to make the first `resume`
		+ This allows the programmer to make the cocall. This allows priming, putting the execution in the right position so that the first user `resume` makes sense
		+ Sure, why not. I don't ask questions


##### A1 Hint(s)

Don't need to do `money` as a coroutine

* Easiest way to write a coroutine is to pretend you're a freshman
	- Just write the code straight up and get it working
	- Then change it into a coroutine
* Much like formatter, our A1Q3 coroutine takes some input values and determines if the input is valid


##### 3.1.3 Correct Coroutine Usage

* Eliminate computation or flag variables retaining information about execution state
* We had our good version of the Fibonacci coroutine
	- However, consider the example using a switch statement
		+ In this case, an explicit flag var controls execution state
		+ Original program structure is lost in the switch


##### 3.1.4 Coroutine Construction

* Fastest way to write a simple coroutine? Write it out directly, with some inputs and output, and take that code and put it in a coroutine, subject to change
	- Works well enough for simple coroutines
	- Put processing code into coroutine main
	- Converting reads if program is consuming or writes if program is producing to `suspend`
		+ Fibonacci consumes nothing and produces Fibonacci numbers --> converts writes (cout) to `suspends`
		+ Formatter consumes chars and only indirectly produces output (as side-effect) --> convert reads (cin) to `suspends`


### 4.0 mC++ Exception Handling Model

* In A1Q3, need to throw an exception from one coroutine to another coroutine
* mC++ exceptions are generated from a specific kind of type, which can be thrown and/or resumed
	- All exception types are grouped into a hierarchy
	- mC++ provides a set of predefined exception-types covering exceptional runtime and I/O events
* mC++ restricts raising to a specific exception type
* Supports two forms of raising, throwing, and resuming
* Supports two kinds of handlers, termination, and resumption, which match with the kind of raise
* Supports propagation of nonlocal and concurrent exceptions
	- Cross-stack exceptions


### 4.1 Exception Type

* C++ allows any type to be used as an exception type. mC++ restricts exception types to those defined by `_Event`

```
_Event exception-type-name {
	...
};
```

* An exception type has all the properties of a class
	- As well, every exception type must have a public default and copy constructor
* An exception is the same as a class-object with respect to creation and destruction

```
_Event D { ... };
D d;
_Resume d;
D *dp = new D;
_Resume *dp;
delete dp;
_Throw D();
```

* Note, C++ `throw` doesn't have all the special features that `_Throw` does


### 4.2 Inherited Members

Each exception type inherits the following members from `uBaseEvent`

...


### 4.3 Raising

...

* Can use `_Throw`, or maybe event `throw`, but the former provides additional funtionality


### 4.4 Handler

* mC++ has two kinds of handlers, termination and resumption. They match with the kind of raise

**Termination**

* The mC++ termination handler is the catch clause of a try block, same as C++

**Resumption**

* A resumption handler is often a corrective action for a failing operation
* Unlike normal routine calls, the call to a resumption handler is dynamically bound rather than statically bound
	- mC++ extends the try block to include resumption handlers
	- Resumption handler is enoted by a `_CatchResume` clause at the end of a `try` block

```
try {
	...
}
_CatchResume(E1 &) { ... }
// more _CatchResume clauses
_CatchResume(...) { ... }
catch(E2 &) { ... }
// more catch clauses
catch(...) { ... }
```

* Any number of resumption handlers can be associated with a `try` block
* All `_CatchResume` handlers much precede any `catch` handlers
	- The former is dynamic, the latter is catch
	- The former goes back to the raise, while the latter continues afterwards
* Like `catch(...)`, `_CatchResume(...)` must appear at the end of the list of the resumption handlers
* **Resumption handler cannot perform a break, continue, or return**

...

Something about unwinding stack

...


### 4.5 Nonlocal Exceptions

* Nonlocal exceptions are exceptions raised by a source execution at a faulting execution
* Nonlocal exceptions are possible because each coroutine (execution) has its own stack
	- Nonlocal has to throw something at someone that has a stack


...


```
Problems with not using coroutines?

Device driver example
> Flow becomes linearized without coroutines. There is a very specific order of execution and it usually involves a method beginning and ending
> This can lead to inefficient code and over-complication, because we're forced to comply with the structure and flow of a regular method
```